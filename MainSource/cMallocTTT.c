#include <stdio.h>#include <stdlib.h>/* #include <MacMemory.h> */#include <MacTypes.h>#include "Tools.h"#include "ulibTypes.h"extern char WarningBuff[256];/*#define DEBUG 1*//*#define DEBUG 2*//*#define DEBUG 3*//*#define DEBUG 4*//* define DEBUG 4 has the thread locks */int cMemoryTest(unsigned long length);int WarningBatch(char *message);void checkall(void);void checkCount(void);int Warning(char *message);static INT8_64 TotalUsed;INT8_64 TotalUsedMaximun;static long stop=1750000000;int cMemoryTest(unsigned long length){	if(TotalUsed+length > stop){	    return 1;	}	return 0;}#ifndef DEBUGvoid *cMalloc(unsigned long length,int tag){	OSErr err;	void *ret;			if(cMemoryTest(length)){	    sprintf(WarningBuff,"cMalloc : Requested (%ld) TotalUsed (%lld) stop (%ld)\n",	           (long)length,TotalUsed,stop);	    Warning(WarningBuff);	    return NULL;	}		tag=tag;	ret=malloc(length);	if(!ret){	    sprintf(WarningBuff,"MemError\n");	    return NULL;	}		TotalUsed += length;		if(TotalUsed > TotalUsedMaximun)TotalUsedMaximun=TotalUsed;		return ret;}void *cRealloc(char *p,unsigned long r,int tag){    unsigned long n,k;	void *giver;	char *give;	if(!p)return NULL;	n=GetPtrSize(p);	if(!(giver=(void *)cMalloc(r,tag))){		sprintf(WarningBuff,"cRealloc out of Memory\n");		WarningBatch(WarningBuff);	    return NULL;	}		give=(char *)giver;		for(k=0;k<r;++k){	    if(k < n){ 	        give[k]=p[k];	    }else{ 	        give[k]=0;	    }	}	cFree((char *)p);	return giver;	}int cFree(char *ptr){	unsigned long n;		n=GetPtrSize(ptr);	TotalUsed -= n;	if(ptr)DisposePtr(ptr);	return 0;}void checkall(){	return;}#endif#ifdef DEBUG#define END_OF_MEMORY 1900000static void  *given[END_OF_MEMORY];static int tagm[END_OF_MEMORY];static int errorprint[END_OF_MEMORY];static long givenlength[END_OF_MEMORY];static int maxgiven;static long memcount;void checkCount(void){	int k,count,taglast;		count=0;	for(k=0;k<maxgiven;++k){	    if(given[k]){	        ++count;	        taglast=tagm[k];	    }	}	if(count){	    sprintf(WarningBuff,"checkall not free %d taglast %d\n",count,taglast);	    WarningBatch(WarningBuff);	}}void checkall(){	int k,count;		count=0;	for(k=0;k<maxgiven;++k){	    if(given[k]){		    sprintf(WarningBuff,"checkall found %ld %lx tag %d\n",(long)given[k],(unsigned long)given[k],tagm[k]);		    Warning(WarningBuff);	        ++count;	    }	}	if(count){	    sprintf(WarningBuff,"checkall not free %d\n",count);	    Warning(WarningBuff);	}else{	    maxgiven=0;	   fprintf(stderr,"checkall all Ok\n");	}}int cFind(char *p);int cFind(char *p){	int k;		for(k=0;k<maxgiven;++k){	    if(given[k] == p)goto found;	}	sprintf(WarningBuff,"Error Could Not Find %p %ld\n",p,(long)p);	Warning(WarningBuff);	return 0;found:	return 1;}#endif#if defined(DEBUG) && DEBUG == 2void CheckOverWrite(char *where);void CheckOverWrite(char *where){	unsigned char *add;	unsigned char *give;	long length;	long *fill;	int k;	int n;		for(k=0;k<maxgiven;++k){	    if(given[k]){	    	give=(unsigned char *)given[k];				fill=(long *)(give-2*sizeof(long));			if((fill[0] != -1L || fill[1] != -1L) && errorprint[k] == 0){				sprintf(WarningBuff,"%s Memory Over  Write Before k %d tag %d\n",where,k,tagm[k]);				Warning(WarningBuff);	    				errorprint[k] = 1;			}	        		length=givenlength[k];		    for(n=0;n<2*sizeof(long);++n){		        add=give+length+n;		        if(*(add) != 255 && errorprint[k] == 0){					sprintf(WarningBuff,"%s Memory Over Write After k %d tag %d\n",where,k,tagm[k]);					Warning(WarningBuff);	    					errorprint[k] = 1;					break;		        		        		        }		    }	    	    }	}}void *cMalloc(unsigned long r,int tag){	void *giver;	unsigned char *give;	unsigned char *add;	long *fill,length;	OSErr err;	int k;	int n;		CheckOverWrite("cMalloc");		for(k=0;k<maxgiven;++k){	    if(!given[k])goto empty;	}		if(++maxgiven >= END_OF_MEMORY){	       sprintf(WarningBuff,"cMalloc Debug out of table\n");	       Warning(WarningBuff);	       exit(1);	}	k=maxgiven-1;empty:	length = r;		r += 4*sizeof(long);		if(!(giver=(void *)malloc(r))){	       sprintf(WarningBuff,"cMalloc Debug out of Memory maxgiven %ld memcount %ld\n",maxgiven,memcount);	       Warning(WarningBuff);	       exit(1);	}		give=(unsigned char *)giver;		fill=(long *)give;		fill[0] = -1L;	fill[1] = -1L;	    memcount += r;        givenlength[k]=length;        for(n=0;n<2*sizeof(long);++n){        add=give+2*sizeof(long)+length+n;        *(add) = 255;    }    	given[k]=give+2*sizeof(long);	tagm[k]=tag;	return give+2*sizeof(long);}void *cRealloc(char *p,unsigned long r,int tag){	void *giver;	char *give;	    unsigned long n,k,kl;	if(!p)return NULL;		CheckOverWrite("cRealloc");				for(k=0;k<maxgiven;++k){	    if(given[k] == p)goto found;	}		sprintf(WarningBuff," Error Tried to cRealloc %ld\n",p);	Warning(WarningBuff);	return 0;found:	give=p-2*sizeof(long);		n=GetPtrSize(give);	if(!(giver=(void *)cMalloc(r,tag))){		sprintf(WarningBuff,"cRealloc out of Memory\n");		Warning(WarningBuff);	    return NULL;	}		give=(char *)giver;	for(kl=0;kl<r;++kl){	    if(kl < n){ 	        give[kl]=p[kl];	    }else{ 	        give[kl]=0;	    }	}	cFree((char *)p);	return giver;	}int cFree(char *p){	char *give;	int k;	CheckOverWrite("cFree");		for(k=0;k<maxgiven;++k){	    if(given[k] == p)goto found;	}	sprintf(WarningBuff,"Error Tried to free %lx %ld\n",(unsigned long)p,(long)p);	Warning(WarningBuff);	return 1;found:	give=p-2*sizeof(long);		DisposePtr(give);	given[k]=NULL;	if(k == maxgiven-1){	    --maxgiven;	    if(maxgiven < 0 )maxgiven=0;	}		return 0;}#elif defined(DEBUG) && DEBUG == 1void *cMalloc(unsigned long r,int tag){	void *give;	OSErr err;	int k;		for(k=0;k<maxgiven;++k){	    if(!given[k])goto empty;	}		if(++maxgiven >= END_OF_MEMORY){	       sprintf(WarningBuff,"cMalloc Debug out of table\n");	       Warning(WarningBuff);	       exit(1);	}	k=maxgiven-1;empty:	if(!(give=(void *)malloc(r))){	       sprintf(WarningBuff,"cMalloc Debug out of Memory maxgiven %ld memcount %ld\n",maxgiven,memcount);	       Warning(WarningBuff);	       exit(1);	}    memcount += r;	given[k]=give;	tagm[k]=tag;	return give;}void *cRealloc(char *p,unsigned long r,int tag){	void *giver;	char *give;	    unsigned long n,k,kl;	if(!p)return NULL;		for(k=0;k<maxgiven;++k){	    if(given[k] == p)goto found;	}	sprintf(WarningBuff,"Error Tried to realloc %ld\n",p);	Warning(WarningBuff);	return 0;found:	n=GetPtrSize(p);	if(!(giver=(void *)cMalloc(r,tag))){		sprintf(WarningBuff,"cRealloc out of Memory\n");		Warning(WarningBuff);	    return NULL;	}		give=(char *)giver;	for(kl=0;kl<r;++kl){	    if(kl < n){ 	        give[kl]=p[kl];	    }else{ 	        give[kl]=0;	    }	}	cFree((char *)p);	return giver;	}int cFree(char *p){	int k;		for(k=0;k<maxgiven;++k){	    if(given[k] == p)goto found;	}	sprintf(WarningBuff,"Error Tried to free %lx %ld\n",(unsigned long)p,(long)p);	Warning(WarningBuff);	return 1;found:	DisposePtr(p);	given[k]=NULL;	if(k == maxgiven-1){	    --maxgiven;	    if(maxgiven < 0 )maxgiven=0;	}		return 0;}#elif  defined(DEBUG) && DEBUG == 3void *cMalloc(unsigned long r,int tag){	void *giver;	unsigned char *give;	unsigned char *add;	long *fill,length;	OSErr err;	int k;	int n;			for(k=0;k<maxgiven;++k){	    if(!given[k])goto empty;	}		if(++maxgiven >= END_OF_MEMORY){	       sprintf(WarningBuff,"cMalloc Debug out of table\n");	       Warning(WarningBuff);	       exit(1);	}	k=maxgiven-1;empty:	length = r;		r += 4*sizeof(long);		if(!(giver=(void *)malloc(r))){	       sprintf(WarningBuff,"cMalloc Debug out of Memory maxgiven %ld memcount %ld\n",maxgiven,memcount);	       Warning(WarningBuff);	       exit(1);	}		give=(unsigned char *)giver;		fill=(long *)give;		fill[0] = -1L;	fill[1] = -1L;	    memcount += r;        givenlength[k]=length;        for(n=0;n<2*sizeof(long);++n){        add=give+2*sizeof(long)+length+n;        *(add) = 255;    }    	given[k]=give+2*sizeof(long);	tagm[k]=tag;	return give+2*sizeof(long);}int checkGive(char *where,unsigned char *p,long length);int checkGive(char *where,unsigned char *give,long k){	unsigned char *add;	long length;	long *fill;	int n;		if(!give)return 1;	fill=(long *)(give-2*sizeof(long));	if((fill[0] != -1L || fill[1] != -1L)){		sprintf(WarningBuff,"%s Memory Over  Write Before k %d tag %d\n",where,k,tagm[k]);		Warning(WarningBuff);	    	}		    	length=givenlength[k];    for(n=0;n<2*sizeof(long);++n){        add=give+length+n;        if(*(add) != 255){			sprintf(WarningBuff,"%s Memory Over Write After k %d tag %d\n",where,k,tagm[k]);			Warning(WarningBuff);	    			break;		        		                }    }			return 0;}void *cRealloc(char *p,unsigned long r,int tag){	void *giver;	char *give;	    unsigned long n,k,kl;	if(!p)return NULL;		for(k=0;k<maxgiven;++k){	    kl=k;	    if(given[k] == p)goto found;	}		sprintf(WarningBuff," Error Tried to cRealloc %ld\n",p);	Warning(WarningBuff);	return 0;found:	checkGive("cRealloc",(unsigned char *)p,kl);		give=p-2*sizeof(long);		n=GetPtrSize(give);	if(!(giver=(void *)cMalloc(r,tag))){		sprintf(WarningBuff,"cRealloc out of Memory\n");		Warning(WarningBuff);	    return NULL;	}		give=(char *)giver;	for(kl=0;kl<r;++kl){	    if(kl < n){ 	        give[kl]=p[kl];	    }else{ 	        give[kl]=0;	    }	}	cFree((char *)p);	return giver;	}int cFree(char *p){	char *give;	int kl;	int k;		for(k=0;k<maxgiven;++k){	    kl=k;	    if(given[k] == p)goto found;	}	sprintf(WarningBuff,"Error Tried to free %lx %ld\n",(unsigned long)p,(long)p);	Warning(WarningBuff);	return 1;found:	checkGive("cFree",(unsigned char *)p,kl);	give=p-2*sizeof(long);		DisposePtr(give);	given[k]=NULL;	if(k == maxgiven-1){	    --maxgiven;	    if(maxgiven < 0 )maxgiven=0;	}		return 0;}#elif  defined(DEBUG) && DEBUG == 4#include <pthread.h>pthread_mutex_t mutex;static long total;void *cMalloc(unsigned long r,int tag){	void *give;	char buff[256];	int k;	static int one=0;		if(one == 0){	    pthread_mutex_init(&mutex,NULL);	    one=1;	}		pthread_mutex_lock(&mutex);		for(k=0;k<maxgiven;++k){	    if(!given[k])goto empty;	}		if(++maxgiven >= END_OF_MEMORY){	       sprintf(buff,"cMalloc Debug  out of table\n");	       fprintf(stderr,"%s\n",buff);	       exit(1);	}	k=maxgiven-1;empty:	if(!(give=(void *)calloc(r+4L,1))){	       sprintf(buff,"cMalloc Requested (%ld) out of Memory total Used (%ld) \n",r,total);	       fprintf(stderr,"%s\n",buff);	       exit(1);	}		total += r+4L;	given[k]=give;	tagm[k]=tag;			pthread_mutex_unlock(&mutex);	return give;}void *cRealloc(char *p,unsigned long r,int tag){	void *give;	char buff[256];	int k;		pthread_mutex_lock(&mutex);		for(k=0;k<maxgiven;++k){	    if(given[k] == p)goto found;	}	sprintf(buff,"Error Tried to realloc %ld\n",(long)p);	fprintf(stderr,"%s\n",buff);	pthread_mutex_unlock(&mutex);	return 0;found:	if(!(give=(void *)realloc(p,r+4L))){		sprintf(buff,"realloc out of Memory\n");		fprintf(stderr,"%s\n",buff);	       	exit(1);	}	given[k]=give;	tagm[k]=tag;	pthread_mutex_unlock(&mutex);	return give;	}int cFree(char *p){	char buff[256];	int k;		pthread_mutex_lock(&mutex);	for(k=0;k<maxgiven;++k){	    if(given[k] == p)goto found;	}	/* sprintf(buff,"Error Tried to free %lu rank %d\n",(unsigned long)p,xg.rank); */	sprintf(buff,"Error Tried to free %lu\n",(unsigned long)p);	fprintf(stderr,"%s\n",buff);	pthread_mutex_unlock(&mutex);	return 1;found:	free(p);	given[k]=NULL;	if(k == maxgiven-1){	    --maxgiven;	    if(maxgiven < 0 )maxgiven=0;	}		pthread_mutex_unlock(&mutex);	return 0;}#endifint zerol(char *s,unsigned long n){    if(!s || (n <= 0))return 1;#if DEBUG == 2	CheckOverWrite("zerol1");#endif	while(n-- > 0)*s++ = 0;	#if DEBUG == 2	CheckOverWrite("zerol2");#endif	return 0;}